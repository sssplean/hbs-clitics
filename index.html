<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ve≈æbaƒç enklitika</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="sentence-container" id="sentence"></div>
  <div class="enclitic-options" id="encliticOptions"></div>
  <div class="buttons">
    <button onclick="loadExample()">üîÅ Novi primjer</button>
    <button onclick="checkAnswer()">‚úÖ Gotovo</button>
  </div>
  <div id="feedback"></div>

  <script src="enclitics-data.js"></script>
  <script>
    let currentExample = {};
    // key: slot index, value: array of enclitic elements in that slot
    let insertedMap = {};
    // currently dragged element when moving from a slot
    let draggedEl = null;

    function getNextIndex(idx) {
      const val = parseFloat(idx);
      return parseFloat(((Math.floor(val * 10) + 1) / 10).toFixed(1));
    }

    function renumberFollowingSlots(startSlot) {
      if (!startSlot) return;
      const base = Math.floor(parseFloat(startSlot.dataset.index));
      let slot = startSlot;
      while (slot && slot.classList.contains('drop-slot')) {
        const oldIdx = parseFloat(slot.dataset.index);
        if (Math.floor(oldIdx) !== base) break;
        const newIdx = parseFloat((oldIdx - 0.1).toFixed(1));
        slot.dataset.index = newIdx;
        if (insertedMap[oldIdx]) {
          insertedMap[newIdx] = insertedMap[oldIdx];
          delete insertedMap[oldIdx];
        }
        slot = slot.nextElementSibling;
      }
    }

          function removeSlotIfNeeded(slot) {
        if (!slot || slot.children.length) return;
        const parent = slot.parentElement;
        const idx = parseFloat(slot.dataset.index);
        const base = Math.floor(idx);

        const sameBaseSlots = Array.from(parent.querySelectorAll('.drop-slot'))
          .filter(s => Math.floor(parseFloat(s.dataset.index)) === base);
        const subSlots = sameBaseSlots.filter(s => parseFloat(s.dataset.index) !== base);
        const baseHasEnclitic = insertedMap[base] && insertedMap[base].length;

        if (idx === base) {
          if (subSlots.length) {
            const last = subSlots[subSlots.length - 1];
            if (!baseHasEnclitic && last.children.length === 0) {
              parent.removeChild(last);
              delete insertedMap[last.dataset.index];
            }
          }
          return;
        }

        if (subSlots.length === 1) {
          if (!baseHasEnclitic) {
            parent.removeChild(slot);
            delete insertedMap[slot.dataset.index];
          }
          return;
        }

        const next = slot.nextElementSibling;

        if (next && next.classList.contains('drop-slot') &&
            Math.floor(parseFloat(next.dataset.index)) === base &&
            next.children.length === 0) {
          parent.removeChild(next);
          delete insertedMap[next.dataset.index];
          renumberFollowingSlots(next);
          return;
        }

        parent.removeChild(slot);
        delete insertedMap[slot.dataset.index];

        if (next && next.classList.contains('drop-slot') &&
            Math.floor(parseFloat(next.dataset.index)) === base) {
          renumberFollowingSlots(next);
        }
      }

    function optionExists(text) {
      return Array.from(document.querySelectorAll('.enclitic-option'))
        .some(opt => opt.textContent === text);
    }

    function createOption(text) {
      if (optionExists(text)) return;
      const opt = document.createElement('div');
      opt.className = 'enclitic-option';
      opt.textContent = text;
      opt.draggable = true;
      opt.addEventListener('dragstart', e => {
        e.dataTransfer.setData('text/plain', text);
        e.dataTransfer.setData('source', 'bank');
      });
      document.getElementById('encliticOptions').appendChild(opt);
    }

    function loadExample() {
      insertedMap = {};
      const sentence = document.getElementById('sentence');
      const encliticOptions = document.getElementById('encliticOptions');
      const feedback = document.getElementById('feedback');
      sentence.innerHTML = '';
      encliticOptions.innerHTML = '';
      feedback.textContent = '';

      currentExample = encliticsExamples[Math.floor(Math.random() * encliticsExamples.length)];

      currentExample.parts.forEach((word, i) => {
        const wordBlock = document.createElement('div');
        wordBlock.className = 'word-block';
        wordBlock.textContent = word;
        sentence.appendChild(wordBlock);

        const dropSlot = createDropSlot(i + 1);
        sentence.appendChild(dropSlot);
      });

      // Extra slot after last word
      const lastSlot = createDropSlot(currentExample.parts.length + 1);
      sentence.appendChild(lastSlot);

      // Create draggable enclitics
      const allOptions = [...currentExample.enclitics, ...currentExample.distractors].sort(() => Math.random() - 0.5);
      allOptions.forEach(text => createOption(text));

      // Allow dropping enclitics back to bank
      encliticOptions.ondragover = e => e.preventDefault();
      encliticOptions.ondrop = e => {
        e.preventDefault();
        const enclitic = e.dataTransfer.getData('text/plain');
        const source = e.dataTransfer.getData('source');
        const from = e.dataTransfer.getData('from');

        if (source === 'slot' && draggedEl) {
          const slot = draggedEl.parentElement;
          draggedEl.remove();
          const arr = insertedMap[from] || [];
          insertedMap[from] = arr.filter(el => el !== draggedEl);
          if (!insertedMap[from].length) delete insertedMap[from];
          removeSlotIfNeeded(slot);
          draggedEl = null;
          createOption(enclitic);
        }
      };
    }

    function createDropSlot(index) {
      const dropSlot = document.createElement('div');
      dropSlot.className = 'drop-slot';
      dropSlot.dataset.index = index;

      dropSlot.addEventListener('dragover', e => {
        e.preventDefault();
        dropSlot.classList.add('over');
      });

      dropSlot.addEventListener('dragleave', () => {
        dropSlot.classList.remove('over');
      });

      dropSlot.addEventListener('drop', e => {
        e.preventDefault();
        dropSlot.classList.remove('over');
        const enclitic = e.dataTransfer.getData('text/plain');
        const source = e.dataTransfer.getData('source');
        const from = e.dataTransfer.getData('from');
        let idx = dropSlot.dataset.index;

        if (source === 'slot' && from === idx) {
          draggedEl = null;
          return;
        }

        if (dropSlot.children.length > 0) {
          const existing = dropSlot.firstElementChild;
          const oldText = existing.textContent;
          existing.remove();
          const arr = insertedMap[idx] || [];
          insertedMap[idx] = arr.filter(el => el !== existing);
          if (!insertedMap[idx].length) delete insertedMap[idx];
          createOption(oldText);
        }

        // If dragging from another slot, remove that specific element
        if (source === 'slot' && draggedEl) {
          const fromArr = insertedMap[from] || [];
          insertedMap[from] = fromArr.filter(el => el !== draggedEl);
          if (!insertedMap[from].length) delete insertedMap[from];
          const fromSlot = draggedEl.parentElement;
          draggedEl.remove();

          const fromIdx = parseFloat(fromSlot.dataset.index);
          const sameBase = Math.floor(fromIdx) === Math.floor(parseFloat(idx));
          const isImmediate = fromSlot.nextElementSibling === dropSlot;

          if (sameBase && isImmediate) {
            const oldIdx = idx;
            fromSlot.remove();
            dropSlot.dataset.index = fromSlot.dataset.index;
            if (insertedMap[oldIdx]) {
              insertedMap[dropSlot.dataset.index] = insertedMap[oldIdx];
              delete insertedMap[oldIdx];
            }
            renumberFollowingSlots(dropSlot.nextElementSibling);
          } else {
            removeSlotIfNeeded(fromSlot);
          }
          draggedEl = null;
          idx = dropSlot.dataset.index;
        }

        // Remove same enclitic from other slots (only one instance allowed)
        for (const idx in insertedMap) {
          const arr = insertedMap[idx];
          const found = arr.find(el => el.textContent === enclitic);
          if (found) {
            found.remove();
            insertedMap[idx] = arr.filter(el => el !== found);
            if (!insertedMap[idx].length) delete insertedMap[idx];
          }
        }

        const enclEl = document.createElement('div');
        enclEl.className = 'inserted-enclitic';
        enclEl.textContent = enclitic;
        enclEl.draggable = true;

        enclEl.addEventListener('dragstart', ev => {
          draggedEl = enclEl;
          ev.dataTransfer.setData('text/plain', enclitic);
          ev.dataTransfer.setData('source', 'slot');
          ev.dataTransfer.setData('from', dropSlot.dataset.index);
        });

        enclEl.addEventListener('dblclick', () => {
          const i = dropSlot.dataset.index;
          const arr = insertedMap[i] || [];
          insertedMap[i] = arr.filter(el => el !== enclEl);
          if (!insertedMap[i].length) delete insertedMap[i];
          enclEl.remove();
          removeSlotIfNeeded(dropSlot);
          createOption(enclitic);
        });

        dropSlot.appendChild(enclEl);
        insertedMap[idx] = [enclEl];

        // Remove from bank if source is bank
        if (source === 'bank') {
          const options = document.querySelectorAll('.enclitic-option');
          options.forEach(opt => {
            if (opt.textContent === enclitic) opt.remove();
          });
        }

        const nextIdx = getNextIndex(idx);
        if (!document.querySelector(`.drop-slot[data-index="${nextIdx}"]`)) {
          const newSlot = createDropSlot(nextIdx);
          dropSlot.parentElement.insertBefore(newSlot, dropSlot.nextElementSibling);
        }
      });

      return dropSlot;
    }

    function checkAnswer() {
      const feedback = document.getElementById('feedback');
      const insertedPairs = [];
      Object.keys(insertedMap).map(k => parseInt(k)).sort((a,b) => a - b).forEach(idx => {
        insertedMap[idx].forEach(el => insertedPairs.push([idx, el.textContent, el]));
      });

      const expectedPairs = currentExample.enclitics.map((e, i) => [currentExample.correctIndexes[i], e]);
      const isCorrect = insertedPairs.length === expectedPairs.length &&
        insertedPairs.every((p, i) => expectedPairs[i] && p[0] === expectedPairs[i][0] && p[1] === expectedPairs[i][1]);

      // Highlight result
      insertedPairs.forEach((p, i) => {
        const el = p[2];
        el.classList.remove('correct', 'incorrect');
        if (expectedPairs[i] && p[0] === expectedPairs[i][0] && p[1] === expectedPairs[i][1]) {
          el.classList.add('correct');
        } else {
          el.classList.add('incorrect');
        }
      });

      feedback.textContent = isCorrect ? '‚úÖ Taƒçno!' : '‚ùå Nije taƒçno.';
      feedback.style.color = isCorrect ? 'green' : 'red';
    }

    document.addEventListener('DOMContentLoaded', loadExample);
  </script>
</body>
</html>
