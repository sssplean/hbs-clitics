<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enklitika Trener</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="sentence-container" id="sentence"></div>
  <div class="enclitic-options" id="encliticOptions"></div>
  <div class="buttons">
    <button onclick="loadExample()">🔁 Novi primjer</button>
    <button onclick="checkAnswer()">✅ Gotovo</button>
  </div>
  <div id="feedback"></div>

  <script src="enclitics-data.js"></script>
  <script>
    let currentExample = {};
    // key: slot index, value: array of enclitic elements in that slot
    let insertedMap = {};
    // currently dragged element when moving from a slot
    let draggedEl = null;

    function optionExists(text) {
      return Array.from(document.querySelectorAll('.enclitic-option'))
        .some(opt => opt.textContent === text);
    }

    function createOption(text) {
      if (optionExists(text)) return;
      const opt = document.createElement('div');
      opt.className = 'enclitic-option';
      opt.textContent = text;
      opt.draggable = true;
      opt.addEventListener('dragstart', e => {
        e.dataTransfer.setData('text/plain', text);
        e.dataTransfer.setData('source', 'bank');
      });
      document.getElementById('encliticOptions').appendChild(opt);
    }

    function loadExample() {
      insertedMap = {};
      const sentence = document.getElementById('sentence');
      const encliticOptions = document.getElementById('encliticOptions');
      const feedback = document.getElementById('feedback');
      sentence.innerHTML = '';
      encliticOptions.innerHTML = '';
      feedback.textContent = '';

      currentExample = encliticsExamples[Math.floor(Math.random() * encliticsExamples.length)];

      currentExample.parts.forEach((word, i) => {
        const wordBlock = document.createElement('div');
        wordBlock.className = 'word-block';
        wordBlock.textContent = word;
        sentence.appendChild(wordBlock);

        const dropSlot = createDropSlot(i + 1);
        sentence.appendChild(dropSlot);
      });

      // Extra slot after last word
      const lastSlot = createDropSlot(currentExample.parts.length + 1);
      sentence.appendChild(lastSlot);

      // Create draggable enclitics
      const allOptions = [...currentExample.enclitics, ...currentExample.distractors].sort(() => Math.random() - 0.5);
      allOptions.forEach(text => createOption(text));

      // Allow dropping enclitics back to bank
      encliticOptions.ondragover = e => e.preventDefault();
      encliticOptions.ondrop = e => {
        e.preventDefault();
        const enclitic = e.dataTransfer.getData('text/plain');
        const source = e.dataTransfer.getData('source');
        const from = e.dataTransfer.getData('from');

        if (source === 'slot' && draggedEl) {
          draggedEl.remove();
          const arr = insertedMap[from] || [];
          insertedMap[from] = arr.filter(el => el !== draggedEl);
          if (!insertedMap[from].length) delete insertedMap[from];
          draggedEl = null;
          createOption(enclitic);
        }
      };
    }

    function createDropSlot(index) {
      const dropSlot = document.createElement('div');
      dropSlot.className = 'drop-slot';
      dropSlot.dataset.index = index;

      dropSlot.addEventListener('dragover', e => {
        e.preventDefault();
        dropSlot.classList.add('over');
      });

      dropSlot.addEventListener('dragleave', () => {
        dropSlot.classList.remove('over');
      });

      dropSlot.addEventListener('drop', e => {
        e.preventDefault();
        dropSlot.classList.remove('over');
        const enclitic = e.dataTransfer.getData('text/plain');
        const source = e.dataTransfer.getData('source');
        const from = e.dataTransfer.getData('from');

        // If dragging from another slot, remove that specific element
        if (source === 'slot' && draggedEl) {
          const fromArr = insertedMap[from] || [];
          insertedMap[from] = fromArr.filter(el => el !== draggedEl);
          if (!insertedMap[from].length) delete insertedMap[from];
          draggedEl.remove();
          draggedEl = null;
        }

        // Remove same enclitic from other slots (only one instance allowed)
        for (const idx in insertedMap) {
          const arr = insertedMap[idx];
          const found = arr.find(el => el.textContent === enclitic);
          if (found) {
            found.remove();
            insertedMap[idx] = arr.filter(el => el !== found);
            if (!insertedMap[idx].length) delete insertedMap[idx];
          }
        }

        const enclEl = document.createElement('div');
        enclEl.className = 'inserted-enclitic';
        enclEl.textContent = enclitic;
        enclEl.draggable = true;

        enclEl.addEventListener('dragstart', ev => {
          draggedEl = enclEl;
          ev.dataTransfer.setData('text/plain', enclitic);
          ev.dataTransfer.setData('source', 'slot');
          ev.dataTransfer.setData('from', index);
        });

        enclEl.addEventListener('dblclick', () => {
          const arr = insertedMap[index] || [];
          insertedMap[index] = arr.filter(el => el !== enclEl);
          if (!insertedMap[index].length) delete insertedMap[index];
          enclEl.remove();
          createOption(enclitic);
        });

        dropSlot.appendChild(enclEl);
        if (!insertedMap[index]) insertedMap[index] = [];
        insertedMap[index].push(enclEl);

        // Remove from bank if source is bank
        if (source === 'bank') {
          const options = document.querySelectorAll('.enclitic-option');
          options.forEach(opt => {
            if (opt.textContent === enclitic) opt.remove();
          });
        }
      });

      return dropSlot;
    }

    function checkAnswer() {
      const feedback = document.getElementById('feedback');
      const insertedPairs = [];
      Object.keys(insertedMap).map(k => parseInt(k)).sort((a,b) => a - b).forEach(idx => {
        insertedMap[idx].forEach(el => insertedPairs.push([idx, el.textContent, el]));
      });

      const expectedPairs = currentExample.enclitics.map((e, i) => [currentExample.correctIndexes[i], e]);
      const isCorrect = insertedPairs.length === expectedPairs.length &&
        insertedPairs.every((p, i) => expectedPairs[i] && p[0] === expectedPairs[i][0] && p[1] === expectedPairs[i][1]);

      // Highlight result
      insertedPairs.forEach((p, i) => {
        const el = p[2];
        el.classList.remove('correct', 'incorrect');
        if (expectedPairs[i] && p[0] === expectedPairs[i][0] && p[1] === expectedPairs[i][1]) {
          el.classList.add('correct');
        } else {
          el.classList.add('incorrect');
        }
      }

      feedback.textContent = isCorrect ? '✅ Tačno!' : '❌ Nije tačno.';
      feedback.style.color = isCorrect ? 'green' : 'red';
    }

    document.addEventListener('DOMContentLoaded', loadExample);
  </script>
</body>
</html>
